line(1)
# Fibonacci series
def @fibonacci(num)
    if num <= 1 :
        return num
    else:
        return @fibonacci(num - 1) + @fibonacci(num - 2)
    end
end

def @fibonacci(num)
    if num <= 1 :
        return num
    else:
        return @fibonacci(num - 1) + @fibonacci(num - 2)
    end
end

final num = @fibonacci(10)

println(num)


line(2)
# Bubble Sort
def @checkList(arr)
    if  not arr and arr.is_empty():
        return false
    end
    return true
end

def @bubblesort(arr=[])
    # Check if the arr is empty or the arr are numbers
    if not @checkList(arr):
        raise Exception(fm"Expected List, got '%{typeof(arr)}'")
    else:
        if arr.is_number() or arr.is_string():
            for i = 0 to arr.length:
                for j = 0 to arr.length - 1:
                    if arr[j] > arr[j + 1]:
                        let temp = arr[j]
                        arr[j] = arr[j + 1]
                        arr[j + 1] = temp
                    end
                end
            end
        else:
            raise Exception(fm"Expected List of numbers")
        end
    end
    return arr
end

let arr = ["Orange", "Apple", "Banana", "Mango"]
let arr2 = [5, 3, 8, 6, 2, 1, 4, 7]
println(arr)
println(@bubblesort(arr)) # ["Apple", "Banana", "Mango", "Orange"]
println(arr2)
println(@bubblesort(arr2)) # [1, 2, 3, 4, 5, 6, 7, 8]





line(3)
# Binary Tree. leetcode.com example
class TreeNode()
    def __@init__(self, x)
        self.val = x
        self.left = none
        self.right = none
    end
end


def @treeNodeToString(root)
    if not root:
        return "[]"
    end
    let output = ""
    let queue = [root]
    let current = 0
    while current != len(queue):
        let node = queue[current]
        current += 1

        if not node:
            output += "null, "
            current += 1
            continue
        end
        output += fm"%{node.val}, "
        queue.append(node.left)
        queue.append(node.right)
    end
    return "[" + output[:-2] + "]"
end

def @stringToTreeNode(input)
    let input = input.strip()
    let input = input[1:-1]
    if not input:
        return none
    end
    let inputValues = in input.split(',') as s: s.strip()
    let root = TreeNode(int(inputValues[0]))
    let nodeQueue = [root]
    let front = 0
    let index = 1
    while index < len(inputValues):
        let node = nodeQueue[front]
        front = front + 1

        let item = inputValues[index]
        index = index + 1
        if item != "null":
            let leftNumber = int(item)
            node.left = TreeNode(leftNumber)
            nodeQueue.append(node.left)
        end
        if index >= len(inputValues):
            break
        end
        item = inputValues[index]
        index = index + 1
        if item != "null":
            let rightNumber = int(item)
            node.right = TreeNode(rightNumber)
            nodeQueue.append(node.right)
        end
    end
    return root
end


def @prettyPrintTree(node, prefix="", isLeft=true)
    if not node:
        print("Empty Tree")
        return
    end
    if node.right:
        if isLeft:
            @prettyPrintTree(node.right, prefix + "│   ", false)
        else:
            @prettyPrintTree(node.right, prefix + "    ", false)
        end
    end
    if isLeft:
        print(prefix + "└── " + fm"%{node.val}")
    else:
        print(prefix + "┌── " + fm"%{node.val}")
    end
    if node.left:
        if isLeft:
            @prettyPrintTree(node.left, prefix + "    ", true)
        else:
            @prettyPrintTree(node.left, prefix + "│   ", true)
        end
    end
end


def @main()
    let root = @stringToTreeNode("[1,2,3,4,5,6,7]")
    @prettyPrintTree(root)
end

@main()
