# Reference to the class is passed to each methods of a class as the first argument, regardless if the class is called or not.
# For example, if we have a class called "Dog", and we have a function called "bark", then the first argument of bark will be "Dog" the class itself.
# Example:
# class Dog
#   def bark(self)
#     print("Woof!")
#   end
# end
# dog = Dog()
# dog.bark() # prints "Woof!"
# Dog.bark(dog) # prints "Woof!" # even though the Dog class is not called, it is still passed as the first argument.

class Employee
    @employee_db_id = "iobherbndfiuyirre" # @ means static variable and cannot be changed
    url = "http://www.google.com" # url is a instance variable and can be changed
    def __@init__(self)
        self.name = name
        self.age = age
    end
    def create(self, name, age)
        self.name = name
        self.age = age
    end
    def get_employee_db_id(self)
        return self.@employee_db_id
    end
    def str(self)
        return fm"Employee(%{self.name}, %{self.age})"
    end
end

let employee = Employee
#employee.@employee_db_id = "changed" # This is a static variable, so a warning will be raised if you try to change it
employee.url = "http://www.new.com" # this is not a static variable, so no value will be changed
println(employee.@employee_db_id)
println(employee.url)

class Accounts()
    accounts_list = []
    def __@init__(self, config)
    end
    def create_account(self, data)
        self.accounts_list.append(data)
        self.accounts = self.accounts_list
    end
    def get_account(self, account_id)
        return self.accounts.find(def (account) -> account.id == account_id)
    end
    def get_accounts(self)
        return self.accounts
    end
end


class Client()
    def __@init__(self, config)
        if not config.hasprop("client_id") or not config.hasprop("client_secret"):
            raise KeyError("client_id or client_secret is missing")
        end
        self.client_id = config["client_id"]
        self.client_secret = config["client_secret"]
        self.accounts = Accounts(config)
    end
    def get_config(self)
        return self.config
    end
    def str(self)
        return fm"Client ID: %{self.client_id}, Client Secret: %{self.client_secret}"
    end
end


class Wallet()
    def __@init__(self)
        self.balance = 0
    end
    def deposit(self, amount)
        self.balance += amount
    end
    def withdraw(self, amount)
        if self.balance < amount:
            raise ValueError("Insufficient funds")
        end
        self.balance -= amount
    end
    def get_balance(self)
        return fm"Your balance is $%{self.balance}"
    end
    def str(self)
        return fm"Wallet balance: $%{self.balance}"
    end
end


# class BankAccount(Wallet)
#     def __@init__(self)
#         self.balance = 0
#     end
#     def get_balance(self)
#         return fm"Balance: $%{self.balance}"
#     end
#     def str(self)
#         return fm"Bank Account: $%{self.balance}"
#     end
# end



final config = {
    "client_id": "isodnosd6eebecwye53283",
    "client_secret": '35h9ew8734b34723wewe7te7'
}


let account_data1 = {
    "id": "12345",
    "name": "David s Account",
    "balance": "100.00"
}

let account_data2 = {
    "id": "12346",
    "name": "Jane d Account",
    "balance": "200.00"
}

let client = Client(config)
client.accounts.create_account(account_data1)
client.accounts.create_account(account_data2)
let account = client
let david_account = client.accounts.get_account("12345")
let jane_account = client.accounts.get_account("12346")
println(david_account)
println(jane_account)
println(client.accounts.get_accounts())

let wallet = Wallet()
wallet.deposit(100)
wallet.withdraw(50)
wallet.withdraw(18.50)
println(wallet.get_balance())

# let bank_account = BankAccount()
# bank_account.deposit(100)
# bank_account.withdraw(50)
# println(bank_account.get_balance())
