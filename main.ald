# def curry(func, num)
#     let i = 0
#     def t ()
#         print(i)
#     end
#     return {
#         t: t,
#     }
# end

# def func_curr(x, y)
#     return x * y
# end

# curry(func_curr, 2).t()

# def sayHello(greeting: str)
#     return {
#         say: def (name) -> f"%{greeting} %{name}"
#     }
# end

# let greet = sayHello("Hello")
# print(greet.say("World"))

# def testClosure(n)
#     let i = 0
#     def t ()
#         def t2 ()
#             print(i)
#         end
#         return t2
#     end
#     return {
#         t: t,
#     }
# end

# testClosure(2).t()()

# since closure cannot be created in the function, then we return a dict with the closure function as an initializer

def closure(val: int)
    def init()
        print(val)
    end
    return {
        init: init,
    }
end

closure(2).init()

# def sayHello(greeting: str)
#     def init(name: str)
#         print(f"%{greeting} %{name}")
#     end
#     return init
# end

# let greet = sayHello("Hello")
# greet("World") # we get a NameError because greeting is not defined in the scope of the init function

def sayHello(greeting: str)
    def init(name: str)
        print(f"%{greeting} %{name}")
    end
    return {
        init: init,
    }
end
let greet = sayHello("Hello")
greet.init("World") # igreeting is defined in the scope of the init function because it is returned as a dict

# so essentially, we are creating a closure function that is initialized with a value and then we return a dict with the init function as an initializer
# logger example

def logger(type: str)
    def setMessage(msg: str)
        print(f"%{type}: %{msg}")
    end
    def getType()
        return {
            __@init__: def ()
                return {
                    __@init__: def ()
                        return def ()
                            return f'The type is %{type}'
                        end
                    end,
                }
            end,
        }
    end
    return {
        __@init__: setMessage,
        getType: getType,
    }
end

let debug = logger("Debug")
let info = logger("Info")
debug.$("Check out this debug message") # we using an implicit o0bject reference to the __@init__ function
info.$("Check out this info message") # we using an implicit o0bject reference to the __@init__ function
print(debug.getType().$().$()()) # we using an implicit o0bject reference to the getType function
